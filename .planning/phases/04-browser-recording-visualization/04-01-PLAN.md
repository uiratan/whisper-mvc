---
phase: 04-browser-recording-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/AudioUploader.tsx
  - src/hooks/useVoiceRecorder.ts
autonomous: true

must_haves:
  truths:
    - "Native MediaRecorder API is used for audio capture"
    - "Recording state is managed (idle, recording, paused, preview)"
    - "Recording can be discarded or redone directly"
  artifacts:
    - path: "src/hooks/useVoiceRecorder.ts"
      provides: "Recording logic and state management"
      contains: "MediaRecorder"
---

<objective>
Implement the core recording logic using the native MediaRecorder API and a custom React hook.

Purpose: Provide a robust way to capture audio directly in the browser.
Output: useVoiceRecorder hook that manages stream, recorder, and resulting audio blob.
</objective>

<execution_context>
@/home/uira/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-browser-recording-visualization/04-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Create useVoiceRecorder hook</name>
  <files>
    src/hooks/useVoiceRecorder.ts
  </files>
  <action>
Create a custom hook `useVoiceRecorder` that:
1. Requests microphone permissions using `navigator.mediaDevices.getUserMedia`.
2. Initializes `MediaRecorder` with dynamic MIME type support (`audio/webm` for Chrome, `audio/mp4` for Safari).
3. Manages states: `isRecording`, `recordingBlob`, `recordingUrl`, `duration`.
4. Provides methods: `startRecording`, `stopRecording`, `discardRecording`.
5. Handles the 25MB limit by monitoring data chunks (optional but recommended) or simply relying on the stop action.
6. Implements "Direct Redo" logic by clearing previous recording and starting fresh.
  </action>
  <verify>
Check if hook correctly initializes MediaRecorder and produces a Blob/URL upon stopping.
  </verify>
  <done>
- useVoiceRecorder hook implemented
- MediaRecorder correctly handles browser-specific formats
- State management covers recording and preview phases
  </done>
</task>

<task type="auto">
  <name>Integrate Recording State into AudioUploader</name>
  <files>
    src/components/AudioUploader.tsx
  </files>
  <action>
Modify `AudioUploader.tsx` to:
1. Import and use the `useVoiceRecorder` hook.
2. Add a "Record" button/mode that switches the UI from "File Upload" to "Recording Mode".
3. Implement the conflict strategy: "Last Action Wins" (recording replaces selected file).
4. Prepare the UI structure to host the visualizer and preview player (to be implemented in plan 02).
  </action>
  <verify>
Verify that clicking "Record" enters the recording state and stopping creates a preview URL.
  </verify>
  <done>
- AudioUploader integrated with useVoiceRecorder
- Conflict strategy implemented
- Basic recording controls (Start/Stop) added
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. User can start a recording.
2. User can stop a recording.
3. Stopping a recording generates a valid Blob and ObjectURL.
4. "Discard" clears the recording.
5. "Record Again" resets the state correctly.
</verification>

<success_criteria>
- Recording logic works across major browsers.
- State transitions match 04-CONTEXT.md (Manual confirmation, Discard, Redo).
- Recorded audio is correctly captured as a Blob.
</success_criteria>

<output>
After completion, proceed to 04-02-PLAN.md
</output>
